---
title: "Chapter 1: Introduction"
date: 2023-09-07T07:14:32+05:30
draft: false
toc: true
---

## Section 1.1: Language Processors

1. The differences between a compiler and interpreter are as follows.

| Compiler | Interpreter |
|-|-|
| It converts a program in a source language into an equivalent program in a target language. | It appears to directly execute the operations specified in the source code on inputs supplied by the user. |
| Faster runtime. | Slower runtime. |
| Lesser error diagnostics. | More error diagnostics. |

2. 
    1. The advantages of a compiler over an interpreter are as follows.
        * It produces target machine code that runs faster than an interpreter
          mapping inputs to outputs.
        * It secures the source program. Only the compiled executable is needed
          to run the program.
        * It generates more optimized code than the interpreter.
        * The compiled target code can be run on any other system with
          compatible architecture.
    2. The advantages of an interpreter over a compiler are as follows.
        * It has better error diagnostics than a compiler.
        * It is easier to debug with an interpreter than using a compiled
          executable.
        * Build times are faster than that of a compiler.

3. The advantages of using a language-processing system that generates assembly
   code are as follows.
    1. The assembly code is portable across architectures, even if the
       processors are of different flavours.
    2. An assembler can be used to generate more optimized machine code.

4. The advantages of a source-to-source translator with C as the target language
   are as follows.
    1. Existing C compilers can be used to compile the code.
    2. Since C is a general purpose language, any program in the source language
       can be translated to an equivalent C program if the translator supports
       it.

5. An assembler needs to perform the following tasks.
    1. It converts the assembly code into taregt machine code.
    2. It optimizes the assembly code to reduce the number off machine
       instructions executed upon assembling.

## Section 1.3: The Evolution of Programming Languages

1. 
    | Term | Language |
    |:-|:-|
    | Imperative | C, C++, Java |
    | Declarative | ML |
    | von Neumann | C, Fortran |
    | Object-oriented | C++, Java, VB |
    | Functional | ML |
    | Third-generation | C, C++, Cobol, Fortran, Java, Lisp |
    | Fourth-generation | Perl, Python |
    | Scripting | Perl, Python, Lisp |

## Section 1.6: Programming Language Basics

1. In the first block, the value of the outer `i` changes to 6, which explains
   the values of `x` and `z`. The other values are because of the declared
   values of `i` and `j` in that scope. The values are tabulated below.

    | Variable | Value |
    |:-|:-|
    | `w` | 13 |
    | `x` | 11 |
    | `y` | 13 |
    | `z` | 11 |

2. Using the same reasoning as in the previous problem, the final values are
   tabulated below.

    | Variable | Value |
    |:-|:-|
    | `w` | 9 |
    | `x` | 7 |
    | `y` | 13 |
    | `z` | 11 |

3. The scope of each declaration is tabulated below.

    | Variable | Block Where Declared | Scope |
    |-|-|-|
    | `w` | `B1` | `B1`, `B2` |
    | `x` | `B1` | `B1` |
    | `y` | `B1` | `B1`, `B2`, `B3`, `B4` |
    | `z` | `B1` | `B1`, `B4` |
    | `x` | `B2` | `B2` |
    | `z` | `B2` | `B2`, `B3` |
    | `w` | `B3` | `B3` |
    | `x` | `B3` | `B3` |
    | `w` | `B4` | `B4`, `B5` |
    | `x` | `B4` | `B4`, `B5` |
    | `y` | `B5` | `B5` |
    | `z` | `B5` | `B5` |

4. The output on executing this C code is as shown below.
    ``` 
    3
    2
    ```